# RFC6455

## Введение

### Фон

Исторически создание веб-приложений, которым требуется двусторонняя связь между клиентом и сервером (например, мгновенные сообщения и игровые приложения), требовало злоупотребления HTTP для опроса сервера на предмет обновлений при отправке уведомлений вверх в виде отдельных вызовов HTTP [RFC6202].

Это приводит к ряду проблем:
- Сервер вынужден использовать несколько различных базовых TCP-соединений для каждого клиента: одно для отправки информации клиенту и новое для каждого входящего сообщения.
- Протокол передачи данных имеет высокие накладные расходы, поскольку каждое сообщение от клиента к серверу имеет HTTP-заголовок.
- Скрипт на стороне клиента вынужден поддерживать сопоставление исходящих соединений с входящими, чтобы отслеживать ответы.

   Более простым решением было бы использование одного TCP-соединения для двустороннего трафика.  Это то, что предоставляет протокол WebSocket. В сочетании с API WebSocket [WSAPI] он предоставляет альтернативу опросу HTTP для двусторонней связи со веб-страницы на удаленный сервер.

   Ту же технику можно использовать для различных веб-приложений: игр, биржевых котировок, многопользовательских приложений с одновременным редактированием, пользовательских интерфейсов, предоставляющих серверные службы в реальном времени и т. д.

   Протокол WebSocket разработан для замены существующих технологий двусторонней связи, использующих HTTP в качестве транспортного уровня, чтобы воспользоваться существующей инфраструктурой (прокси, фильтрация, аутентификация). Такие технологии были реализованы как компромисс между эффективностью и надежностью, потому что HTTP изначально не предназначался для использования в двусторонней связи (см. [RFC6202] для дальнейшего обсуждения). Протокол WebSocket пытается решить задачи существующих технологий двусторонней связи HTTP в контексте существующей инфраструктуры HTTP; таким образом, он предназначен для работы через порты HTTP 80 и 443, а также для поддержки прокси-серверов и промежуточных узлов HTTP, даже если это подразумевает некоторую специфику, связанную с текущим окружением. Однако дизайн не ограничивает WebSocket только HTTP, и будущие реализации могут использовать более простое рукопожатие через выделенный порт без полной переделки всего протокола. Этот последний пункт важен, потому что трафик интерактивных сообщений не соответствует стандартному трафику HTTP и может вызывать необычные нагрузки на некоторые компоненты.

### Обзор протокола

   Протокол состоит из двух частей: рукопожатия и передачи данных.

   Рукопожатие со стороны клиента выглядит следующим образом:

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

   Рукопожатие со стороны сервера выглядит следующим образом:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```
   Ведущая строка от клиента следует формату Request-Line.
   Ведущая строка от сервера следует формату Status-Line. Продукции Request-Line и Status-Line определены в [RFC2616].

   Неупорядоченный набор заголовков следует за ведущей строкой в обоих случаях. Значение этих заголовков определено в разделе 4 этого документа. Могут также присутствовать дополнительные заголовки, такие как cookies [RFC6265]. Формат и разбор заголовков определены в [RFC2616].

   После того как клиент и сервер отправили свои рукопожатия, и если рукопожатие прошло успешно, начинается часть передачи данных. Это двусторонний канал связи, где каждая сторона может, независимо от другой, отправлять данные по своему усмотрению.

   После успешного рукопожатия клиенты и серверы передают данные туда и обратно в концептуальных единицах, в этой спецификации называемых "сообщениями". По сети сообщение состоит из одного или нескольких кадров. Сообщение WebSocket не обязательно соответствует определенному кадрированию сетевого уровня, так как фрагментированное сообщение может быть объединено или разделено промежуточным устройством.

   Кадр имеет связанный тип. Каждый кадр, принадлежащий к одному и тому же сообщению, содержит тот же тип данных. В общем смысле, существуют типы для текстовых данных (которые интерпретируются как текст в UTF-8 [RFC3629]), бинарных данных (интерпретация которых остается на усмотрение приложения) и управляющих кадров (которые не предназначены для пересылки данных для приложения, а вместо этого предназначены для сигнализации на уровне протокола, например, для сигнализации о том, что соединение должно быть закрыто). Эта версия протокола определяет шесть типов кадров и оставляет десять зарезервированными для будущего использования. 

### Открытие рукопожатия

Открытие рукопожатия предназначено для совместимости с серверным программным обеспечением на основе HTTP и промежуточными устройствами, чтобы один порт мог использоваться как HTTP-клиентами, общающимися с этим сервером, так и WebSocket-клиентами, общающимися с этим сервером. С этой целью рукопожатие WebSocket-клиента представляет собой запрос на обновление HTTP:

        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13

   В соответствии с [RFC2616] заголовки полей в рукопожатии могут быть отправлены клиентом в любом порядке, поэтому порядок, в котором получены различные заголовки полей, не имеет значения.

   "Request-URI" метода GET [RFC2616] используется для идентификации конечной точки соединения WebSocket, как для того, чтобы позволить обслуживать несколько доменов с одного IP-адреса, так и для того, чтобы позволить обслуживать несколько конечных точек WebSocket одним сервером.

   Клиент включает имя хоста в заголовок поля |Host| своего рукопожатия в соответствии с [RFC2616], чтобы как клиент, так и сервер могли убедиться, что они согласны с тем, какой хост используется.

   Дополнительные заголовки полей используются для выбора опций в протоколе WebSocket. Типичные опции, доступные в этой версии, это селектор субпротокола (|Sec-WebSocket-Protocol|), список расширений, поддерживаемых клиентом (|Sec-WebSocket-Extensions|), заголовок |Origin| и т. д. Заголовок поля |Sec-WebSocket-Protocol| запроса может использоваться для указания, какие субпротоколы (протоколы на уровне приложений, построенные поверх протокола WebSocket) являются приемлемыми для клиента. Сервер выбирает один из приемлемых протоколов или ни одного из них и отдает эту информацию в своем рукопожатии, чтобы указать, что он выбрал этот протокол.

        Sec-WebSocket-Protocol: chat

   Заголовок поля |Origin| [RFC6454] используется для защиты от несанкционированного использования WebSocket-сервера скриптами, использующими API WebSocket в веб-браузере. Сервер получает информацию об источнике скрипта, создающем запрос на соединение WebSocket. Если сервер не желает принимать соединения из этого источника, он может выбрать отклонить соединение, отправив соответствующий код ошибки HTTP. Этот заголовок поля отправляется браузерными клиентами; для клиентов, не являющихся браузерами, этот заголовок поля может быть отправлен, если это имеет смысл в контексте этих клиентов.

   Наконец, серверу необходимо доказать клиенту, что он получил рукопожатие WebSocket, чтобы сервер не принимал соединения, которые не являются соединениями WebSocket. Это предотвращает атаку на WebSocket-сервер, отправляя ему тщательно сформированные пакеты с использованием XMLHttpRequest [XMLHttpRequest] или отправкой формы.

   Чтобы доказать, что рукопожатие было получено, сервер должен взять две части информации и объ

единить их, чтобы сформировать ответ. Первая часть информации берется из заголовка поля |Sec-WebSocket-Key| в рукопожатии клиента:

        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==

Для этого заголовка поля сервер должен взять значение (как присутствующее в заголовке поля, например, в виде закодированного в base64 [RFC4648] значения без ведущих и завершающих пробелов) и объединить его с уникальным глобальным идентификатором (GUID, [RFC4122]) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" в строковой форме, которая вряд ли будет использоваться сетевыми конечными точками, которые не понимают протокол WebSocket. Затем сформированная строка подвергается хешированию SHA-1 (160 бит) [FIPS.180-3], которое затем кодируется в base64 (см. Раздел 4 [RFC4648]), и этот результат возвращается в рукопожатии сервера.

Конкретно, если, как в примере выше, заголовок поля |Sec-WebSocket-Key| имел значение "dGhlIHNhbXBsZSBub25jZQ==", сервер объединил бы строку "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" для формирования строки "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". Затем сервер берет хеш SHA-1 этой строки, получая значение 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. Затем это значение кодируется в base64 (см. Раздел 4 [RFC4648]), чтобы получить значение "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=". Это значение затем будет отражено в заголовке поля |Sec-WebSocket-Accept|.

Рукопожатие со стороны сервера намного проще, чем рукопожатие со стороны клиента. Первая строка - это HTTP Status-Line, с кодом статуса 101:

```HTTP/1.1 101 Switching Protocols```

Любой код статуса, отличный от 101, указывает на то, что рукопожатие WebSocket не завершено, и семантика HTTP все еще применяется. Заголовки следуют за кодом статуса.

Заголовки полей |Connection| и |Upgrade| завершают HTTP Upgrade. Заголовок поля |Sec-WebSocket-Accept| указывает, готов ли сервер принять соединение. Если он присутствует, этот заголовок должен включать хеш nonce клиента, отправленный в |Sec-WebSocket-Key|, вместе с предопределенным GUID. Любое другое значение не должно интерпретироваться как принятие соединения сервером.
 
```HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```
Эти поля проверяются WebSocket-клиентом для скриптовых страниц. Если значение |Sec-WebSocket-Accept| не совпадает с ожидаемым значением, если заголовок поля отсутствует или если код статуса HTTP не равен 101, соединение не будет установлено, и кадры WebSocket не будут отправлены.

Также можно включить опциональные поля. В этой версии протокола основным опционным полем является |Sec-WebSocket-Protocol|, которое указывает подпротокол, выбранный сервером. Клиенты WebSocket проверяют, включил ли сервер одно из значений, указанных в рукопожатии клиента WebSocket. Сервер, поддерживающий несколько подпротоколов, должен убедиться, что он выбирает один на основе рукопожатия клиента и указывает его в своем рукопожатии.

